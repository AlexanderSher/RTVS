# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See LICENSE in the project root for license information.

call_embedded <- function(name, ...) {
  .Call(paste0('Microsoft.R.Host::Call.', name, collapse = ''), ..., PACKAGE = '(embedding)')
}

external_embedded <- function(name, ...) {
  .External(paste0('Microsoft.R.Host::External.', name, collapse = ''), ..., PACKAGE = '(embedding)')
}

send_notification <- function(name, ...) {
    call_embedded('send_notification', name, list(...))
}

send_request_and_get_response <- function(name, ...) {
    call_embedded('send_request_and_get_response', name, list(...))
}

memory_connection <- function(max_length = NA, expected_length = NA, overflow_suffix = '', eof_marker = '') {
  call_embedded('memory_connection', max_length, expected_length, overflow_suffix, eof_marker)
}

memory_connection_overflown <- function(con) {
  call_embedded('memory_connection_overflown', con)
}

memory_connection_tochar <- function(con) {
  call_embedded('memory_connection_tochar', con)
}

unevaluated_promise <- function(name, env) {
  call_embedded("unevaluated_promise", name, env)
}

is_missing <- function(name, env) {
  call_embedded("is_missing", name, env)
}

is_rdebug <- function(obj) {
  call_embedded("is_rdebug", obj)
}

set_rdebug <- function(obj, debug) {
  call_embedded("set_rdebug", obj, debug)
}

browser_set_debug <- function(n = 1, skip_toplevel = 0) {
  call_embedded("browser_set_debug", n, skip_toplevel)
}

toJSON <- function(obj) {
  call_embedded("toJSON", obj)
}

create_blob <- function(obj) {
    call_embedded("create_blob", obj)
}

get_blob <- function(blob_id) {
    call_embedded("get_blob", blob_id)
}

destroy_blob <- function(blob_id) {
    invisible(call_embedded("destroy_blob", blob_id))
}

NA_if_error <- function(expr) {
  tryCatch(expr, error = function(e) { NA })
}

NULL_if_error <- function(expr) {
  tryCatch(expr, error = function(e) { NULL })
}

# Like toString, but guarantees that result is a single-element character vector.
force_toString <- function(obj) {
  if (is.null(obj) || (length(obj) == 1 && is.atomic(obj) && is.na(obj) && !is.nan(obj))) {
    return('');
  }
  s <- paste0(toString(obj), collapse='');
  if (!is.character(s) || length(s) != 1 || is.na(s)) '' else s;
}

# Guarantees that result is a single-element numeric vector or NA.
force_number <- function(x) {
  if (!is.numeric(x) || length(x) != 1) NA else x;
}

# Like dput, but returns the value as string rather than printing it, and can limit
# the output to a desired length.
dput_str <- function(obj, max_length = NA, expected_length = NA, overflow_suffix = '...') {
  con <- memory_connection(max_length, expected_length, overflow_suffix);
  on.exit(close(con), add = TRUE);
  
  tryCatch({
    dput(obj, con);
  }, error = function(e) {
  });
  
  # Strip leading and trailing whitespace - it is never significant, and there's always
  # at least a trailing '\n' that dput always outputs.
  gsub("^\\s+|\\s+$", "", memory_connection_tochar(con))
}

# Like deparse, but always returns a single string.
deparse_str <- function(x)
    paste0(deparse(x), collapse = '')

# Makes a symbol token (properly quoted with backticks if necessary) out of a symbol or a string.
symbol_token <- function(name) {
  s <- force_toString(name);

  # If it's an empty string, it's not a valid symbol, even if quoted.
  if (identical(s, '')) {
      return(NULL);
  }

  # If it's a valid identifier, it's good to go as is. Because the definition of identifier in R
  # is locale-dependent, be conservative and match ASCII only; excessive quoting is always safe.
  if (grepl('^[A-Za-z_.][A-Za-z0-9_.]*$', name)) {
      return(s);
  }

  # Deparse it - this will take care of all the necessary escaping for everything other than
  # backticks, but will also put double quotes around that we'll remove later.
  s <- deparse_str(force_toString(s));

  # Escape any backticks.
  s <- gsub('`', '\\`', s, fixed = TRUE);

  # Replace surrounding quotes with backticks.
  paste0('`', substr(s, 2, nchar(s) - 1), '`', collapse = '')
}

# Like eval, but will not enter Browse mode if env has its debug bit set
# (e.g. when it has just been stepped into).
safe_eval <- function(expr, env) {
    debug <- is_rdebug(env);
    tryCatch({
        set_rdebug(env, FALSE);
        eval(expr, env)
    }, finally = {
        set_rdebug(env, debug);
    });
}

# Helper to export variable to CSV
export_to_csv <- function(expr, sep, dec) {
    res <- expr
    ln <- length(res) + 1
    filepath <- tempfile('export_', fileext='.csv')
    on.exit(unlink(filepath))
    write.table(res, file=filepath, qmethod='double', col.names=NA, sep=sep, dec=dec)
    readBin(filepath, 'raw', file.info(filepath)$size)
}

# Helper to export current plot to image
export_to_image <- function(device, width, height, resolution) {
    filepath <- tempfile('plot_', fileext='.dat')
    on.exit(unlink(filepath))
    dev.copy(device=device,filename=filepath,width=width,height=height,res=resolution)
    dev.off()
    readBin(filepath, 'raw', file.info(filepath)$size)
}

# Helper to export current plot to pdf
export_to_pdf <- function(width, height) {
    filepath <- tempfile('plot_',fileext='.pdf')
    on.exit(unlink(filepath))
    dev.copy(device=pdf,file=filepath,width=width,height=height)
    dev.off()
    readBin(filepath, 'raw', file.info(filepath)$size)
}

# Helper to publish rmarkdown files remotely
rmarkdown_publish <- function(blob_id, output_format, encoding) {
    # Create temp file to store the rmarkdown file
    rmdpath <- tempfile('rmd_', fileext = '.rmd');
    on.exit(unlink(rmdpath));
    writeBin(get_blob(blob_id), rmdpath);

    # Get file extension from format
    fileext <- if (identical(output_format, 'html_document')) {
        '.html'
    } else if (identical(output_format, 'pdf_document')) {
        '.pdf'
    } else if (identical(output_format, 'word_document')) {
        '.docx'
    } else {
        '.tmp'
    }

    # Create temp file to store the markdown render output
    output_filepath <- tempfile('rmd_', fileext = fileext);
    on.exit(unlink(output_filepath));

    rmarkdown::render(rmdpath, output_format = output_format, output_file = output_filepath,  output_dir = tempdir(), encoding = encoding);
    readBin(output_filepath, 'raw', file.info(output_filepath)$size);
}

package_lock_state <- function(package_name, package_lib) {
    file_path_i386 <- paste0(package_lib, '/', package_name, '/libs/i386/', package_name, '.dll');
    file_path_x64 <- paste0(package_lib, '/', package_name, '/libs/x64/', package_name, '.dll');
    
    lock_state <- if (file.exists(file_path_x64)) {
        call_embedded('get_package_lock_state', file_path_x64);
    } else {
        'unlocked'
    }

    if (identical(lock_state, 'unlocked')) {
        lock_state <- if (file.exists(file_path_i386)) {
        call_embedded('get_package_lock_state', file_path_i386);
        } else {
            'unlocked'
        }
    }

    lock_state
}